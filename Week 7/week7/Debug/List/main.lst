###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       16/Oct/2023  20:29:41
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\project_test\user\main.c
#    Command line =  
#        -f C:\Users\pnu10\AppData\Local\Temp\EWD54E.tmp
#        (C:\project_test\user\main.c -D USE_STDPERIPH_DRIVER -D STM32F10X_CL
#        -lC C:\project_test\Debug\List -o C:\project_test\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\project_test\libraries\CMSIS\DeviceSupport\ -I
#        C:\project_test\libraries\CMSIS\DeviceSupport\Startup\ -I
#        C:\project_test\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\ -I
#        C:\project_test\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\ -I
#        C:\project_test\user\ -I C:\project_test\user\inc\ -Ol -I "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  C:\project_test\Debug\List\main.lst
#    Object file  =  C:\project_test\Debug\Obj\main.o
#
###############################################################################

C:\project_test\user\main.c
      1          
      2          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0xe000e100
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
      3          #include "stm32f10x_exti.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_usart.h"
      6          #include "stm32f10x_rcc.h"
      7          
      8          #include "misc.h"
      9          
     10          /* function prototype */
     11          //LED @@ @@@

   \                                 In section .data, align 4
     12          int LED_mode = 1, now = 1;
   \                     LED_mode:
   \   00000000   0x00000001         DC32 1

   \                                 In section .data, align 4
   \                     now:
   \   00000000   0x00000001         DC32 1
     13          
     14          void RCC_Configure(void);
     15          void GPIO_Configure(void);
     16          void EXTI_Configure(void);
     17          void USART1_Init(void);
     18          void NVIC_Configure(void);
     19          
     20          void EXTI15_10_IRQHandler(void);
     21          
     22          void Delay(void);
     23          
     24          void sendDataUART1(uint16_t data);
     25          
     26          //---------------------------------------------------------------------------------------------------
     27          

   \                                 In section .text, align 2, keep-with-next
     28          void RCC_Configure(void)
     29          {
   \                     RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     30          	// TODO: Enable the APB2 peripheral clock using the function 'RCC_APB2PeriphClockCmd'
     31          	
     32          	/* UART TX/RX port clock enable */
     33          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     34          	/* Button S1, S2, S3 port clock enable */
     35          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     36                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     37          	/* LED port clock enable */
     38          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     39          	/* USART1 clock enable */
     40          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF44F 0x4080      MOV      R0,#+16384
   \   00000028   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     41          	/* Alternate Function IO clock enable */
     42          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     43          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void GPIO_Configure(void)
     46          {
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     47              GPIO_InitTypeDef GPIO_InitStructure;
     48          
     49          	// TODO: Initialize the GPIO pins using the structure 'GPIO_InitTypeDef' and the function 'GPIO_Init'
     50          	
     51              /* Button S1, S2, S3 pin setting */
     52              
     53              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_13;
   \   00000002   0xF242 0x0010      MOVW     R0,#+8208
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     54              GPIO_InitStructure.GPIO_Speed = 0x0;
                                                   ^
Warning[Pe188]: enumerated type mixed with another type
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0002      STRB     R0,[SP, #+2]
     55              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000010   0x2028             MOVS     R0,#+40
   \   00000012   0xF88D 0x0003      STRB     R0,[SP, #+3]
     56              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40011000
   \   0000001C   0x.... 0x....      BL       GPIO_Init
     57              
     58              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000020   0xF44F 0x6080      MOV      R0,#+1024
   \   00000024   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     59              GPIO_InitStructure.GPIO_Speed = 0x0;
                                                   ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     60              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   0000002E   0x2028             MOVS     R0,#+40
   \   00000030   0xF88D 0x0003      STRB     R0,[SP, #+3]
     61              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40010c00
   \   0000003A   0x.... 0x....      BL       GPIO_Init
     62              
     63              /* LED pin setting*/
     64              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7;
   \   0000003E   0x209C             MOVS     R0,#+156
   \   00000040   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     65              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xF88D 0x0002      STRB     R0,[SP, #+2]
     66              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000004A   0x2010             MOVS     R0,#+16
   \   0000004C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     67              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40011400
   \   00000056   0x.... 0x....      BL       GPIO_Init
     68          	
     69              /* UART pin setting */
     70              //TX
     71              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   0000005A   0xF44F 0x7000      MOV      R0,#+512
   \   0000005E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     72              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0xF88D 0x0002      STRB     R0,[SP, #+2]
     73              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000068   0x2018             MOVS     R0,#+24
   \   0000006A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     74              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000006E   0x4669             MOV      R1,SP
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x40010800
   \   00000074   0x.... 0x....      BL       GPIO_Init
     75              //RX
     76              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000078   0xF44F 0x6080      MOV      R0,#+1024
   \   0000007C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     77              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000080   0x2003             MOVS     R0,#+3
   \   00000082   0xF88D 0x0002      STRB     R0,[SP, #+2]
     78              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000086   0x2028             MOVS     R0,#+40
   \   00000088   0xF88D 0x0003      STRB     R0,[SP, #+3]
     79              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000008C   0x4669             MOV      R1,SP
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x40010800
   \   00000092   0x.... 0x....      BL       GPIO_Init
     80          }
   \   00000096   0xBD01             POP      {R0,PC}          ;; return
     81          

   \                                 In section .text, align 2, keep-with-next
     82          void EXTI_Configure(void)
     83          {
   \                     EXTI_Configure: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
     84              EXTI_InitTypeDef EXTI_InitStructure;
     85          
     86          	// TODO: Select the GPIO pin (Joystick, button) used as EXTI Line using function 'GPIO_EXTILineConfig'
     87          	// TODO: Initialize the EXTI using the structure 'EXTI_InitTypeDef' and the function 'EXTI_Init'
     88          	
     89              /* Button S1 */
     90              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource4);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       GPIO_EXTILineConfig
     91              EXTI_InitStructure.EXTI_Line = EXTI_Line4;
   \   0000000A   0x2010             MOVS     R0,#+16
   \   0000000C   0x9000             STR      R0,[SP, #+0]
     92              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0004      STRB     R0,[SP, #+4]
     93              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000014   0x200C             MOVS     R0,#+12
   \   00000016   0xF88D 0x0005      STRB     R0,[SP, #+5]
     94              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF88D 0x0006      STRB     R0,[SP, #+6]
     95              EXTI_Init(&EXTI_InitStructure);
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       EXTI_Init
     96          
     97              /* Button S2 */
     98              
     99              GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource10);
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       GPIO_EXTILineConfig
    100              EXTI_InitStructure.EXTI_Line = EXTI_Line10;
   \   0000002E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000032   0x9000             STR      R0,[SP, #+0]
    101              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0004      STRB     R0,[SP, #+4]
    102              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   0000003A   0x200C             MOVS     R0,#+12
   \   0000003C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    103              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0006      STRB     R0,[SP, #+6]
    104              EXTI_Init(&EXTI_InitStructure);
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       EXTI_Init
    105              /* Button S3 */
    106              
    107              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
   \   0000004C   0x210D             MOVS     R1,#+13
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x.... 0x....      BL       GPIO_EXTILineConfig
    108              EXTI_InitStructure.EXTI_Line = EXTI_Line13;
   \   00000054   0xF44F 0x5000      MOV      R0,#+8192
   \   00000058   0x9000             STR      R0,[SP, #+0]
    109              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    110              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000060   0x200C             MOVS     R0,#+12
   \   00000062   0xF88D 0x0005      STRB     R0,[SP, #+5]
    111              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF88D 0x0006      STRB     R0,[SP, #+6]
    112              EXTI_Init(&EXTI_InitStructure);
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x.... 0x....      BL       EXTI_Init
    113          
    114          	// NOTE: do not select the UART GPIO pin used as EXTI Line here
    115          }
   \   00000072   0xBD07             POP      {R0-R2,PC}       ;; return
    116          

   \                                 In section .text, align 2, keep-with-next
    117          void USART1_Init(void)
    118          {
   \                     USART1_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    119          	USART_InitTypeDef USART1_InitStructure;
    120          
    121          	// Enable the USART1 peripheral
    122          	USART_Cmd(USART1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   00000006   0x.... 0x....      BL       USART_Cmd
    123          	
    124          	// TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    125          	USART1_InitStructure.USART_BaudRate = 9600;
   \   0000000A   0xF44F 0x5016      MOV      R0,#+9600
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    126          	USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    127                  USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    128                  USART1_InitStructure.USART_Parity = USART_Parity_No;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    129                  USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000022   0x200C             MOVS     R0,#+12
   \   00000024   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    130                  USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    131                  
    132                  USART_Init(USART1, &USART1_InitStructure);
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   00000032   0x.... 0x....      BL       USART_Init
    133                  
    134          	// TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    135          	
    136                  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0xF240 0x5125      MOVW     R1,#+1317
   \   0000003C   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   0000003E   0x.... 0x....      BL       USART_ITConfig
    137                  
    138                  
    139          }
   \   00000042   0xB005             ADD      SP,SP,#+20
   \   00000044   0xBD00             POP      {PC}             ;; return
    140          

   \                                 In section .text, align 2, keep-with-next
    141          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    142          
    143              NVIC_InitTypeDef NVIC_InitStructure;
    144              
    145              // TODO: fill the arg you want
    146              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
   \   00000002   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    147          
    148              // TODO: Initialize the NVIC using the structure 'NVIC_InitTypeDef' and the function 'NVIC_Init'
    149              
    150              // Button S1
    151              
    152              NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
   \   0000000A   0x200A             MOVS     R0,#+10
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    153              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0003      STRB     R0,[SP, #+3]
    154              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    155              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    156              NVIC_Init(&NVIC_InitStructure);
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       NVIC_Init
    157              // Button S2,
    158              
    159              NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   00000028   0x2028             MOVS     R0,#+40
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    160              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0003      STRB     R0,[SP, #+3]
    161              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0001      STRB     R0,[SP, #+1]
    162              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    163              NVIC_Init(&NVIC_InitStructure);
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x.... 0x....      BL       NVIC_Init
    164               // Button S3,
    165              
    166              NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   00000046   0x2028             MOVS     R0,#+40
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
    167              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    168              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF88D 0x0001      STRB     R0,[SP, #+1]
    169              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    170              NVIC_Init(&NVIC_InitStructure);
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x.... 0x....      BL       NVIC_Init
    171              // UART1
    172          	// 'NVIC_EnableIRQ' is only required for USART setting
    173              NVIC_EnableIRQ(USART1_IRQn);
   \   00000064   0x2025             MOVS     R0,#+37
   \   00000066   0x.... 0x....      BL       __NVIC_EnableIRQ
    174              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   0000006A   0x2025             MOVS     R0,#+37
   \   0000006C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    175              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // TODO
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF88D 0x0001      STRB     R0,[SP, #+1]
    176              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; // TODO
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xF88D 0x0002      STRB     R0,[SP, #+2]
    177              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    178              NVIC_Init(&NVIC_InitStructure);
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x.... 0x....      BL       NVIC_Init
    179          }
   \   00000088   0xBD01             POP      {R0,PC}          ;; return
    180          

   \                                 In section .text, align 2, keep-with-next
    181          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    182          	uint16_t word;
    183              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD016             BEQ.N    ??USART1_IRQHandler_0
    184              	// the most recent received data by the USART1 peripheral
    185                  word = USART_ReceiveData(USART1);
   \   00000010   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
    186          
    187                  // TODO implement
    188                  if(word == 'a')
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0x2961             CMP      R1,#+97
   \   0000001C   0xD103             BNE.N    ??USART1_IRQHandler_1
    189                  {
    190                    LED_mode = 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable9_6
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xE006             B.N      ??USART1_IRQHandler_2
    191                  }
    192                  else if(word == 'b')
   \                     ??USART1_IRQHandler_1: (+1)
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x2862             CMP      R0,#+98
   \   0000002A   0xD103             BNE.N    ??USART1_IRQHandler_2
    193                  {
    194                    LED_mode = -1;
   \   0000002C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000030   0x....             LDR.N    R1,??DataTable9_6
   \   00000032   0x6008             STR      R0,[R1, #+0]
    195                  }
    196                  
    197                  
    198                  // clear 'Read data register not empty' flag
    199              	USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \                     ??USART1_IRQHandler_2: (+1)
   \   00000034   0xF240 0x5125      MOVW     R1,#+1317
   \   00000038   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   0000003A   0x.... 0x....      BL       USART_ClearITPendingBit
    200              }
    201          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    202          

   \                                 In section .text, align 2, keep-with-next
    203          void EXTI4_IRQHandler(void) {
   \                     EXTI4_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    204            if (EXTI_GetITStatus(EXTI_Line4) != RESET) {
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00B             BEQ.N    ??EXTI4_IRQHandler_0
    205          		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_4) == Bit_RESET) {
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40011000
   \   00000010   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??EXTI4_IRQHandler_1
    206          			// TODO implement
    207                            LED_mode = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable9_6
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    208          		}
    209          		EXTI_ClearITPendingBit(EXTI_Line4);
   \                     ??EXTI4_IRQHandler_1: (+1)
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0x.... 0x....      BL       EXTI_ClearITPendingBit
    210          	}
    211          }
   \                     ??EXTI4_IRQHandler_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    212          

   \                                 In section .text, align 2, keep-with-next
    213          void EXTI15_10_IRQHandler(void) { // when the button is pressed
   \                     EXTI15_10_IRQHandler: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    214          
    215              if (EXTI_GetITStatus(EXTI_Line10) != RESET) {
   \   00000002   0xF44F 0x6080      MOV      R0,#+1024
   \   00000006   0x.... 0x....      BL       EXTI_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00E             BEQ.N    ??EXTI15_10_IRQHandler_0
    216          		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_10) == Bit_RESET) {
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40010c00
   \   00000014   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD103             BNE.N    ??EXTI15_10_IRQHandler_1
    217          			// TODO implement
    218                            LED_mode = -1;
   \   0000001C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000020   0x....             LDR.N    R1,??DataTable9_6
   \   00000022   0x6008             STR      R0,[R1, #+0]
    219          		}
    220          		EXTI_ClearITPendingBit(EXTI_Line10);
   \                     ??EXTI15_10_IRQHandler_1: (+1)
   \   00000024   0xF44F 0x6080      MOV      R0,#+1024
   \   00000028   0x.... 0x....      BL       EXTI_ClearITPendingBit
    221          	}
    222              if (EXTI_GetITStatus(EXTI_Line13) != RESET) {
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \   0000002C   0xF44F 0x5000      MOV      R0,#+8192
   \   00000030   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD01A             BEQ.N    ??EXTI15_10_IRQHandler_2
    223          		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == Bit_RESET) {
   \   00000038   0xF44F 0x5100      MOV      R1,#+8192
   \   0000003C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40011000
   \   0000003E   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD10F             BNE.N    ??EXTI15_10_IRQHandler_3
    224          			// TODO implement
    225                            char msg[] = "TEAM10.\r\n";
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x....             LDR.N    R1,??DataTable9_7
   \   0000004A   0xE891 0x001C      LDM      R1,{R2-R4}
   \   0000004E   0xE880 0x001C      STM      R0,{R2-R4}
    226                            for(int i = 0; i < sizeof(msg); i++) {
   \   00000052   0x2400             MOVS     R4,#+0
   \   00000054   0xE005             B.N      ??EXTI15_10_IRQHandler_4
    227                              sendDataUART1(msg[i]);
   \                     ??EXTI15_10_IRQHandler_5: (+1)
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x5D00             LDRB     R0,[R0, R4]
   \   0000005A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0x.... 0x....      BL       sendDataUART1
    228                            }
   \   00000060   0x1C64             ADDS     R4,R4,#+1
   \                     ??EXTI15_10_IRQHandler_4: (+1)
   \   00000062   0x2C0A             CMP      R4,#+10
   \   00000064   0xD3F7             BCC.N    ??EXTI15_10_IRQHandler_5
    229          		}
    230                  EXTI_ClearITPendingBit(EXTI_Line13);
   \                     ??EXTI15_10_IRQHandler_3: (+1)
   \   00000066   0xF44F 0x5000      MOV      R0,#+8192
   \   0000006A   0x.... 0x....      BL       EXTI_ClearITPendingBit
    231          	}
    232          }
   \                     ??EXTI15_10_IRQHandler_2: (+1)
   \   0000006E   0xBD1F             POP      {R0-R4,PC}       ;; return
    233          
    234          // TODO: Create Joystick interrupt handler functions
    235          
    236                  
    237          

   \                                 In section .text, align 2, keep-with-next
    238          void Delay(void) {
    239          	int i;
    240          
    241          	for (i = 0; i < 2000000; i++) {}
   \                     Delay: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??Delay_0
   \                     ??Delay_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_0: (+1)
   \   00000006   0x....             LDR.N    R1,??DataTable9_8  ;; 0x1e8480
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xDBFB             BLT.N    ??Delay_1
    242          }
   \   0000000C   0x4770             BX       LR               ;; return
    243          

   \                                 In section .text, align 2, keep-with-next
    244          void LED_Loop(int mode) {
   \                     LED_Loop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    245            now = now + mode;
   \   00000002   0x....             LDR.N    R1,??DataTable9_9
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x1840             ADDS     R0,R0,R1
   \   00000008   0x....             LDR.N    R1,??DataTable9_9
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    246            if(now == 0) now = 4;
   \   0000000C   0x....             LDR.N    R0,??DataTable9_9
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD102             BNE.N    ??LED_Loop_0
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x....             LDR.N    R1,??DataTable9_9
   \   00000018   0x6008             STR      R0,[R1, #+0]
    247            if(now == 5) now = 0;
   \                     ??LED_Loop_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable9_9
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2805             CMP      R0,#+5
   \   00000020   0xD102             BNE.N    ??LED_Loop_1
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable9_9
   \   00000026   0x6008             STR      R0,[R1, #+0]
    248            
    249            if(now == 1) {
   \                     ??LED_Loop_1: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable9_9
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD110             BNE.N    ??LED_Loop_2
    250              GPIO_ResetBits(GPIOD, GPIO_Pin_2);
   \   00000030   0x2104             MOVS     R1,#+4
   \   00000032   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   00000034   0x.... 0x....      BL       GPIO_ResetBits
    251              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \   00000038   0x2108             MOVS     R1,#+8
   \   0000003A   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_SetBits
    252              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \   00000040   0x2110             MOVS     R1,#+16
   \   00000042   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   00000044   0x.... 0x....      BL       GPIO_SetBits
    253              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   0000004C   0x.... 0x....      BL       GPIO_SetBits
   \   00000050   0xE03D             B.N      ??LED_Loop_3
    254            }
    255            else if(now == 2) {
   \                     ??LED_Loop_2: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable9_9
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD110             BNE.N    ??LED_Loop_4
    256              GPIO_ResetBits(GPIOD, GPIO_Pin_3);
   \   0000005A   0x2108             MOVS     R1,#+8
   \   0000005C   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   0000005E   0x.... 0x....      BL       GPIO_ResetBits
    257              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \   00000062   0x2104             MOVS     R1,#+4
   \   00000064   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   00000066   0x.... 0x....      BL       GPIO_SetBits
    258              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \   0000006A   0x2110             MOVS     R1,#+16
   \   0000006C   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   0000006E   0x.... 0x....      BL       GPIO_SetBits
    259              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \   00000072   0x2180             MOVS     R1,#+128
   \   00000074   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   00000076   0x.... 0x....      BL       GPIO_SetBits
   \   0000007A   0xE028             B.N      ??LED_Loop_3
    260            }
    261            else if(now == 3) {
   \                     ??LED_Loop_4: (+1)
   \   0000007C   0x....             LDR.N    R0,??DataTable9_9
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x2803             CMP      R0,#+3
   \   00000082   0xD110             BNE.N    ??LED_Loop_5
    262              GPIO_ResetBits(GPIOD, GPIO_Pin_4);
   \   00000084   0x2110             MOVS     R1,#+16
   \   00000086   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   00000088   0x.... 0x....      BL       GPIO_ResetBits
    263              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \   0000008C   0x2104             MOVS     R1,#+4
   \   0000008E   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   00000090   0x.... 0x....      BL       GPIO_SetBits
    264              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \   00000094   0x2108             MOVS     R1,#+8
   \   00000096   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   00000098   0x.... 0x....      BL       GPIO_SetBits
    265              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \   0000009C   0x2180             MOVS     R1,#+128
   \   0000009E   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   000000A0   0x.... 0x....      BL       GPIO_SetBits
   \   000000A4   0xE013             B.N      ??LED_Loop_3
    266            }
    267            else if(now == 4) {
   \                     ??LED_Loop_5: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable9_9
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x2804             CMP      R0,#+4
   \   000000AC   0xD10F             BNE.N    ??LED_Loop_3
    268              GPIO_ResetBits(GPIOD, GPIO_Pin_7);
   \   000000AE   0x2180             MOVS     R1,#+128
   \   000000B0   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   000000B2   0x.... 0x....      BL       GPIO_ResetBits
    269              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \   000000B6   0x2104             MOVS     R1,#+4
   \   000000B8   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   000000BA   0x.... 0x....      BL       GPIO_SetBits
    270              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \   000000BE   0x2108             MOVS     R1,#+8
   \   000000C0   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   000000C2   0x.... 0x....      BL       GPIO_SetBits
    271              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \   000000C6   0x2110             MOVS     R1,#+16
   \   000000C8   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011400
   \   000000CA   0x.... 0x....      BL       GPIO_SetBits
    272            }
    273          }        
   \                     ??LED_Loop_3: (+1)
   \   000000CE   0xBD01             POP      {R0,PC}          ;; return
    274          

   \                                 In section .text, align 2, keep-with-next
    275          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    276          	/* Wait till TC is set */
    277          	while ((USART1->SR & USART_SR_TC) == 0);
   \                     ??sendDataUART1_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD5FB             BPL.N    ??sendDataUART1_0
    278          	USART_SendData(USART1, data);
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40013800
   \   00000010   0x.... 0x....      BL       USART_SendData
    279          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    280          

   \                                 In section .text, align 2, keep-with-next
    281          int main(void)
    282          {
   \                     main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    283          
    284              SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    285          
    286              RCC_Configure();
   \   00000006   0x.... 0x....      BL       RCC_Configure
    287          
    288              GPIO_Configure();
   \   0000000A   0x.... 0x....      BL       GPIO_Configure
    289          
    290              EXTI_Configure();
   \   0000000E   0x.... 0x....      BL       EXTI_Configure
    291          
    292              USART1_Init();
   \   00000012   0x.... 0x....      BL       USART1_Init
    293          
    294              NVIC_Configure();
   \   00000016   0x.... 0x....      BL       NVIC_Configure
    295          
    296              while (1) {
    297              	// TODO: implement 
    298              	LED_Loop(LED_mode);
   \                     ??main_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable9_6
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       LED_Loop
    299              	// Delay
    300              	Delay();
   \   00000022   0x.... 0x....      BL       Delay
   \   00000026   0xE7F8             B.N      ??main_0
    301              }
    302              return 0;
                     ^
Warning[Pe111]: statement is unreachable
    303          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     LED_mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     now

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x54 0x45          DC8 "TEAM10.\015\012"
   \              0x41 0x4D    
   \              0x31 0x30    
   \              0x2E 0x0D    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Delay
      24   EXTI15_10_IRQHandler
        24   -> EXTI_ClearITPendingBit
        24   -> EXTI_GetITStatus
        24   -> GPIO_ReadInputDataBit
        24   -> sendDataUART1
       8   EXTI4_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
       8   GPIO_Configure
         8   -> GPIO_Init
       8   LED_Loop
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB2PeriphClockCmd
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
       8   main
         8   -> Delay
         8   -> EXTI_Configure
         8   -> GPIO_Configure
         8   -> LED_Loop
         8   -> NVIC_Configure
         8   -> RCC_Configure
         8   -> SystemInit
         8   -> USART1_Init
       8   sendDataUART1
         8   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  ?_0
      14  Delay
     112  EXTI15_10_IRQHandler
      38  EXTI4_IRQHandler
     116  EXTI_Configure
     152  GPIO_Configure
     208  LED_Loop
       4  LED_mode
     138  NVIC_Configure
      54  RCC_Configure
      64  USART1_IRQHandler
      70  USART1_Init
      30  __NVIC_EnableIRQ
      40  main
       4  now
      22  sendDataUART1

 
     8 bytes in section .data
    12 bytes in section .rodata
 1 098 bytes in section .text
 
 1 098 bytes of CODE  memory
    12 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: 3
